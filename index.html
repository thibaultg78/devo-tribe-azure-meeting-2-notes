<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meeting Transcriber - Tribe Azure</title>
    <link rel="icon" type="image/png" href="https://creativetech-fr.devoteam.com/wp-content/uploads/2021/11/cropped-favicon_dvt_ct.png">
    <link rel="stylesheet" href="styles.css">
    <script src="config.js"></script>
    <script src="prompts.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-content">
                <img src="https://creativetech-fr.devoteam.com/wp-content/uploads/2021/11/cropped-favicon_dvt_ct.png" 
                     alt="Devoteam" class="header-logo">
                <div class="header-text">
                    <h1>Tribe Azure ‚òÅÔ∏è - Meeting Transcriber üìù</h1>
                    <p>Transformez vos r√©unions en CR structur√©s</p>
                </div>
            </div>
        </div>

        <div class="content">
            <!-- Zone d'upload AUDIO -->
            <div class="upload-zone" id="uploadZoneAudio">
                <div class="upload-icon">üéôÔ∏è</div>
                <div class="upload-text">
                    <strong>Glissez un fichier audio</strong> ou cliquez pour s√©lectionner
                </div>
                <div class="supported-formats">
                    Formats support√©s : .m4a, .mp3, .wav, .ogg, .flac
                    <br />
                    (dur√©e du fichier limit√©e √† une r√©union de 1 heure environ)
                </div>
                <div class="file-info" id="fileInfoAudio"></div>
                <input type="file" id="fileInputAudio" accept=".wav,.mp3,.m4a,.ogg,.flac,.webm" style="display: none;" />
            </div>

            <!-- Bouton transcrire -->
            <button class="btn-transcribe" id="btnTranscribe" disabled>
                üéôÔ∏è Transcrire l'audio en texte
            </button>

            <!-- Zone de progression -->
            <div class="progress-zone" id="progressZone">
                <div class="progress-header">
                    <span class="progress-title" id="progressTitle">Transcription en cours...</span>
                    <span class="progress-status" id="progressStatus"></span>
                </div>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
                <div class="progress-details" id="progressDetails">
                    <div class="progress-step" id="step1">
                        <span>‚è≥</span> <span>Upload du fichier audio</span>
                    </div>
                    <div class="progress-step" id="step2">
                        <span>‚è≥</span> <span>Cr√©ation du job de transcription</span>
                    </div>
                    <div class="progress-step" id="step3">
                        <span>‚è≥</span> <span>Transcription en cours</span>
                    </div>
                    <div class="progress-step" id="step4">
                        <span>‚è≥</span> <span>R√©cup√©ration du r√©sultat</span>
                    </div>
                </div>
            </div>

            <div class="or-separator">‚¨áÔ∏è ou collez directement une transcription texte pour la convertir en compte-rendu ‚¨áÔ∏è</div>

            <!-- Zone de texte -->
            <div class="text-input-zone">
                <textarea id="transcriptionText" placeholder="La transcription appara√Ætra ici, ou collez votre propre texte..."></textarea>
            </div>

            <!-- Bouton g√©n√©rer -->
            <button class="btn-generate" id="btnGenerate" disabled>
                üöÄ G√©n√©rer le compte-rendu
            </button>

            <!-- Loading -->
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <div class="loading-text">Claude analyse la transcription...</div>
            </div>

            <!-- Erreur -->
            <div class="error-zone" id="errorZone"></div>

            <!-- R√©sultat -->
            <div class="result-zone" id="resultZone">
                <div class="result-header">
                    <h2>‚úÖ Compte-rendu g√©n√©r√©</h2>
                    <button class="btn-copy" id="btnCopy">üìã Copier</button>
                </div>
                <div class="result-content" id="resultContent"></div>
            </div>
        </div>

        <div class="footer">
            Devoteam M Cloud - Tribe Azure - Meeting Transcriber ü§ñ
            <br />
            Azure Speech + Claude API / OpenAI API
            <br />
            Contact : <a href="mailto:thibault.gibard@devoteam.com">thibault.gibard@devoteam.com</a> üìß
        </div>
    </div>

    <script>
        // √âl√©ments DOM
        const uploadZoneAudio = document.getElementById('uploadZoneAudio');
        const fileInputAudio = document.getElementById('fileInputAudio');
        const fileInfoAudio = document.getElementById('fileInfoAudio');
        const btnTranscribe = document.getElementById('btnTranscribe');
        const progressZone = document.getElementById('progressZone');
        const progressTitle = document.getElementById('progressTitle');
        const progressStatus = document.getElementById('progressStatus');
        const progressBar = document.getElementById('progressBar');
        const transcriptionText = document.getElementById('transcriptionText');
        const btnGenerate = document.getElementById('btnGenerate');
        const loading = document.getElementById('loading');
        const errorZone = document.getElementById('errorZone');
        const resultZone = document.getElementById('resultZone');
        const resultContent = document.getElementById('resultContent');
        const btnCopy = document.getElementById('btnCopy');

        let currentAudioFile = null;

        // Gestion de l'upload AUDIO
        uploadZoneAudio.addEventListener('click', () => fileInputAudio.click());
        
        uploadZoneAudio.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZoneAudio.classList.add('dragover');
        });

        uploadZoneAudio.addEventListener('dragleave', () => {
            uploadZoneAudio.classList.remove('dragover');
        });

        uploadZoneAudio.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZoneAudio.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) handleAudioFile(file);
        });

        fileInputAudio.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleAudioFile(file);
        });

        function handleAudioFile(file) {
            const validExtensions = ['.wav', '.mp3', '.m4a', '.ogg', '.flac', '.webm'];
            const ext = '.' + file.name.split('.').pop().toLowerCase();
            
            if (!validExtensions.includes(ext)) {
                showError('Format audio non support√©.');
                return;
            }

            currentAudioFile = file;
            uploadZoneAudio.classList.add('has-file');
            
            const estimatedMinutes = Math.ceil(file.size / (128 * 1024 / 8) / 60);
            fileInfoAudio.textContent = `‚úì ${file.name} (${formatSize(file.size)}) ‚Ä¢ Dur√©e estim√©e: ~${estimatedMinutes} min`;
            
            btnTranscribe.disabled = false;
        }

        function formatSize(bytes) {
            if (bytes < 1024) return bytes + ' o';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' Ko';
            return (bytes / (1024 * 1024)).toFixed(1) + ' Mo';
        }

        function checkCanGenerate() {
            const hasText = transcriptionText.value.trim().length > 0;
            btnGenerate.disabled = !hasText;
        }

        transcriptionText.addEventListener('input', checkCanGenerate);

        function updateStep(stepNum, status) {
            const step = document.getElementById(`step${stepNum}`);
            const icon = step.querySelector('span:first-child');
            
            step.classList.remove('completed', 'active', 'pending');
            
            if (status === 'completed') {
                step.classList.add('completed');
                icon.textContent = '‚úÖ';
            } else if (status === 'active') {
                step.classList.add('active');
                icon.textContent = 'üîÑ';
            } else {
                step.classList.add('pending');
                icon.textContent = '‚è≥';
            }
        }

        function resetSteps() {
            for (let i = 1; i <= 4; i++) {
                updateStep(i, 'pending');
            }
        }

        // Azure Storage - Auth Header
        async function generateAuthHeader(method, blobName, dateStr, contentLength, contentType) {
            const canonicalizedHeaders = `x-ms-blob-type:BlockBlob\nx-ms-date:${dateStr}\nx-ms-version:2020-10-02`;
            const canonicalizedResource = `/${CONFIG.AZURE_STORAGE_ACCOUNT}/${CONFIG.AZURE_STORAGE_CONTAINER}/${blobName}`;
            
            const stringToSign = [
                method, '', '', contentLength.toString(), '', contentType, '', '', '', '', '', '',
                canonicalizedHeaders, canonicalizedResource
            ].join('\n');

            const encoder = new TextEncoder();
            const keyData = Uint8Array.from(atob(CONFIG.AZURE_STORAGE_KEY), c => c.charCodeAt(0));
            const key = await crypto.subtle.importKey('raw', keyData, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
            const signature = await crypto.subtle.sign('HMAC', key, encoder.encode(stringToSign));
            
            return btoa(String.fromCharCode(...new Uint8Array(signature)));
        }

        // Azure Storage - Upload Blob
        async function uploadToBlob(file) {
            const blobName = `${Date.now()}-${file.name.replace(/[^a-zA-Z0-9.-]/g, '_')}`;
            const url = `https://${CONFIG.AZURE_STORAGE_ACCOUNT}.blob.core.windows.net/${CONFIG.AZURE_STORAGE_CONTAINER}/${blobName}`;
            const dateStr = new Date().toUTCString();
            const contentType = file.type || 'application/octet-stream';
            
            const authSignature = await generateAuthHeader('PUT', blobName, dateStr, file.size, contentType);
            
            const response = await fetch(url, {
                method: 'PUT',
                headers: {
                    'x-ms-blob-type': 'BlockBlob',
                    'x-ms-date': dateStr,
                    'x-ms-version': '2020-10-02',
                    'Content-Type': contentType,
                    'Content-Length': file.size.toString(),
                    'Authorization': `SharedKey ${CONFIG.AZURE_STORAGE_ACCOUNT}:${authSignature}`
                },
                body: file
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Upload √©chou√©: ${response.status} - ${errorText}`);
            }

            return url;
        }

        // Azure Storage - SAS Token
        async function generateSasUrl(blobUrl) {
            const now = new Date();
            const start = new Date(now.getTime() - 5 * 60 * 1000);
            const expiry = new Date(now.getTime() + 60 * 60 * 1000);
            
            const urlObj = new URL(blobUrl);
            const blobName = decodeURIComponent(urlObj.pathname.split('/').slice(2).join('/'));
            
            const permissions = 'r';
            const startStr = start.toISOString().split('.')[0] + 'Z';
            const expiryStr = expiry.toISOString().split('.')[0] + 'Z';
            const version = '2022-11-02';
            
            const stringToSign = [
                permissions, startStr, expiryStr,
                `/blob/${CONFIG.AZURE_STORAGE_ACCOUNT}/${CONFIG.AZURE_STORAGE_CONTAINER}/${blobName}`,
                '', '', 'https', version, 'b', '', '', '', '', '', '', ''
            ].join('\n');

            console.log('String to sign:', stringToSign);

            const encoder = new TextEncoder();
            const keyData = Uint8Array.from(atob(CONFIG.AZURE_STORAGE_KEY), c => c.charCodeAt(0));
            const key = await crypto.subtle.importKey('raw', keyData, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
            const signature = await crypto.subtle.sign('HMAC', key, encoder.encode(stringToSign));
            const sig = btoa(String.fromCharCode(...new Uint8Array(signature)));

            const sasParams = new URLSearchParams({
                'sp': permissions, 'st': startStr, 'se': expiryStr,
                'spr': 'https', 'sv': version, 'sr': 'b', 'sig': sig
            });

            const sasUrl = `${blobUrl}?${sasParams.toString()}`;
            console.log('Generated SAS URL:', sasUrl);
            return sasUrl;
        }

        // Azure Speech - Batch Transcription
        async function createBatchTranscription(audioUrl) {
            const response = await fetch(
                `https://${CONFIG.AZURE_SPEECH_REGION}.api.cognitive.microsoft.com/speechtotext/v3.1/transcriptions`,
                {
                    method: 'POST',
                    headers: {
                        'Ocp-Apim-Subscription-Key': CONFIG.AZURE_SPEECH_KEY,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        contentUrls: [audioUrl],
                        displayName: `Transcription-${Date.now()}`,
                        locale: 'fr-FR',
                        properties: {
                            wordLevelTimestampsEnabled: false,
                            punctuationMode: 'DictatedAndAutomatic',
                            profanityFilterMode: 'None'
                        }
                    })
                }
            );

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Cr√©ation transcription √©chou√©e: ${response.status} - ${errorText}`);
            }

            return await response.json();
        }

        async function checkTranscriptionStatus(transcriptionUrl) {
            const response = await fetch(transcriptionUrl, {
                headers: { 'Ocp-Apim-Subscription-Key': CONFIG.AZURE_SPEECH_KEY }
            });
            if (!response.ok) throw new Error(`Erreur statut: ${response.status}`);
            return await response.json();
        }

        async function getTranscriptionResult(transcriptionUrl) {
            const response = await fetch(`${transcriptionUrl}/files`, {
                headers: { 'Ocp-Apim-Subscription-Key': CONFIG.AZURE_SPEECH_KEY }
            });
            if (!response.ok) throw new Error(`Erreur fichiers: ${response.status}`);

            const files = await response.json();
            const transcriptionFile = files.values.find(f => f.kind === 'Transcription');
            if (!transcriptionFile) throw new Error('Fichier de transcription non trouv√©');

            const contentResponse = await fetch(transcriptionFile.links.contentUrl);
            const content = await contentResponse.json();

            let fullText = '';
            if (content.combinedRecognizedPhrases) {
                fullText = content.combinedRecognizedPhrases.map(p => p.display).join('\n');
            }
            return fullText;
        }

        async function deleteTranscription(transcriptionUrl) {
            try {
                await fetch(transcriptionUrl, {
                    method: 'DELETE',
                    headers: { 'Ocp-Apim-Subscription-Key': CONFIG.AZURE_SPEECH_KEY }
                });
            } catch (e) { console.warn('Cleanup error:', e); }
        }

        // Process transcription
        btnTranscribe.addEventListener('click', async function() {
            if (!currentAudioFile) return;

            progressZone.classList.add('visible');
            errorZone.classList.remove('visible');
            btnTranscribe.disabled = true;
            resetSteps();

            let transcriptionUrl = null;

            try {
                updateStep(1, 'active');
                progressTitle.textContent = 'Upload du fichier...';
                progressBar.style.width = '10%';
                
                const blobUrl = await uploadToBlob(currentAudioFile);
                const sasUrl = await generateSasUrl(blobUrl);
                
                updateStep(1, 'completed');
                progressBar.style.width = '25%';

                updateStep(2, 'active');
                progressTitle.textContent = 'Cr√©ation du job...';
                
                const transcription = await createBatchTranscription(sasUrl);
                transcriptionUrl = transcription.self;
                
                updateStep(2, 'completed');
                progressBar.style.width = '35%';

                updateStep(3, 'active');
                progressTitle.textContent = 'Transcription en cours...';
                progressBar.classList.add('indeterminate');

                let status = 'Running';
                let pollCount = 0;

                while (status === 'Running' || status === 'NotStarted') {
                    await new Promise(resolve => setTimeout(resolve, 5000));
                    
                    const statusResult = await checkTranscriptionStatus(transcriptionUrl);
                    status = statusResult.status;
                    pollCount++;

                    const minutes = Math.floor(pollCount * 5 / 60);
                    const seconds = (pollCount * 5) % 60;
                    progressStatus.textContent = `${minutes}:${seconds.toString().padStart(2, '0')} √©coul√©es`;

                    if (pollCount >= 360) throw new Error('Timeout (30 min max)');
                }

                progressBar.classList.remove('indeterminate');
                if (status === 'Failed') throw new Error('Transcription √©chou√©e');

                updateStep(3, 'completed');
                progressBar.style.width = '80%';

                updateStep(4, 'active');
                progressTitle.textContent = 'R√©cup√©ration...';

                const result = await getTranscriptionResult(transcriptionUrl);
                
                updateStep(4, 'completed');
                progressBar.style.width = '100%';
                progressTitle.textContent = '‚úÖ Transcription termin√©e !';

                transcriptionText.value = result;
                checkCanGenerate();

                await deleteTranscription(transcriptionUrl);

            } catch (error) {
                showError(error.message);
                progressBar.classList.remove('indeterminate');
                if (transcriptionUrl) await deleteTranscription(transcriptionUrl);
            } finally {
                btnTranscribe.disabled = false;
            }
        });

        // Claude API - G√©n√©ration CR
        async function callClaudeAPI(transcription) {
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': CONFIG.ANTHROPIC_API_KEY,
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model: 'claude-sonnet-4-20250514',
                    max_tokens: 4096,
                    system: CLAUDE_SYSTEM_PROMPT,
                    messages: [{ role: 'user', content: `Voici la transcription d'une r√©union. G√©n√®re le compte-rendu structur√©.\n\n---\n\n${transcription}` }]
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error?.message || `Erreur API Claude (${response.status})`);
            }

            const data = await response.json();
            return data.content[0].text;
        }

        // OpenAI API - G√©n√©ration CR
        async function callOpenAI(transcription) {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${CONFIG.OPENAI_API_KEY}`
                },
                body: JSON.stringify({
                    model: CONFIG.OPENAI_MODEL || 'gpt-4o',
                    max_tokens: 4096,
                    messages: [
                        { role: 'system', content: CLAUDE_SYSTEM_PROMPT },
                        { role: 'user', content: `Voici la transcription d'une r√©union. G√©n√®re le compte-rendu structur√©.\n\n---\n\n${transcription}` }
                    ]
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error?.message || `Erreur API OpenAI (${response.status})`);
            }

            const data = await response.json();
            return data.choices[0].message.content;
        }

        // Dispatcher - choisit le provider selon config
        async function generateCR(transcription) {
            if (CONFIG.LLM_PROVIDER === 'openai') {
                return await callOpenAI(transcription);
            } else {
                return await callClaudeAPI(transcription);
            }
        }

        btnGenerate.addEventListener('click', async function() {
            const text = transcriptionText.value.trim();
            if (!text) return;

            loading.classList.add('visible');
            errorZone.classList.remove('visible');
            resultZone.classList.remove('visible');
            btnGenerate.disabled = true;

            try {
                const cr = await generateCR(text);
                resultContent.innerHTML = marked.parse(cr);
                resultZone.classList.add('visible');
            } catch (error) {
                showError(error.message);
            } finally {
                loading.classList.remove('visible');
                checkCanGenerate();
            }
        });

        function showError(message) {
            errorZone.textContent = '‚ö†Ô∏è ' + message;
            errorZone.classList.add('visible');
        }

        btnCopy.addEventListener('click', async () => {
            try {
                await navigator.clipboard.writeText(resultContent.innerText);
                btnCopy.textContent = '‚úì Copi√© !';
                btnCopy.classList.add('copied');
                setTimeout(() => {
                    btnCopy.textContent = 'üìã Copier';
                    btnCopy.classList.remove('copied');
                }, 2000);
            } catch (err) {
                showError('Impossible de copier.');
            }
        });

        checkCanGenerate();
    </script>
</body>
</html>